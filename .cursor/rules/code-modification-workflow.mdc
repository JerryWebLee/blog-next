---
alwaysApply: true
---

# 代码修改工作流规范

## AI 代码修改标准流程

**重要：本项目要求 AI 助手在修改代码时，始终使用工具而非输出代码块。**

## 核心原则

### 为什么使用工具修改代码？

- ✅ 用户可以直接预览和接受修改（Accept）
- ✅ 保持版本控制清晰
- ✅ 避免手动复制粘贴错误
- ✅ 更高效的开发工作流
- ✅ 可以精确定位修改位置
- ✅ 支持增量修改，不影响其他代码

### 禁止的做法

- ❌ 直接输出完整代码块让用户复制
- ❌ 输出部分代码片段让用户手动添加
- ❌ 不先读取文件就假设其内容

## 标准工作流程

### 第 1 步：读取文件

使用 `read_file` 工具读取文件内容，了解：

- 当前代码结构
- 已有的实现
- 代码风格和格式
- 依赖关系和导入

### 第 2 步：分析修改需求

- 确定需要修改的具体位置
- 识别需要保留的代码
- 规划修改范围和影响
- 确保不破坏现有功能

### 第 3 步：执行修改

**必须使用工具进行修改**

- 使用 `edit_file` 或其他相应工具
- 提供足够的上下文（修改前后的代码）
- 确保修改位置唯一可识别

### 第 4 步：验证修改

修改完成后，再次使用 `read_file` 确认：

- 修改已正确应用
- 代码格式正确
- 没有引入语法错误
- 保持代码风格一致

## 不同文件类型的修改规则

### 组件文件 (components/\*)

\`\`\`bash

1. read_file - 读取组件文件
2. 分析修改需求（props、state、hooks）
3. edit_file - 修改组件逻辑或UI
4. read_file - 验证修改结果
   \`\`\`

**注意事项**：

- 保持组件的 TypeScript 类型定义
- 不要破坏现有的 props 接口
- 保持导入语句的顺序和风格

### 页面文件 (app/[lang]/\*)

\`\`\`bash

1. read_file - 读取页面文件
2. 了解路由结构和数据流
3. edit_file - 修改页面逻辑
4. 确保不破坏路由和布局
   \`\`\`

**注意事项**：

- Next.js App Router 的约定
- 保持 async/await 的使用
- 不要修改文件的导出方式

### 工具函数 (lib/_, utils/_)

\`\`\`bash

1. read_file - 读取工具函数
2. 了解函数签名和依赖
3. edit_file - 修改函数实现
4. 确保向后兼容
   \`\`\`

**注意事项**：

- 保持函数签名不变
- 添加必要的类型注解
- 保持导出方式一致

### 样式文件 (styles/_, _.scss)

\`\`\`bash

1. read_file - 读取样式文件
2. 了解现有样式结构和变量
3. edit_file - 添加或修改样式
4. 确保样式不冲突
   \`\`\`

**注意事项**：

- 使用项目定义的 CSS 变量
- 保持 Tailwind 和 SCSS 的使用规范
- 不要覆盖全局样式

### 配置文件 (_.config._, tsconfig.json)

\`\`\`bash

1. read_file - 完整读取配置文件
2. 确认修改的配置项
3. edit_file - 谨慎修改配置
4. 验证配置语法
   \`\`\`

**注意事项**：

- 配置文件修改影响整个项目
- 修改前确认影响范围
- 保持配置的兼容性

## 工作流程示例

### 示例 1：优化博客卡片组件

\`\`\`markdown
**任务**：优化博客卡片上的分类和标签UI

**步骤**：

1. read_file("components/blog/post-card.tsx")
   - 查看当前的分类标签实现
   - 了解标签的布局结构
2. 分析修改需求：
   - 改进分类标签的视觉效果
   - 优化标签的布局和间距
   - 添加悬停动画效果
3. edit_file("components/blog/post-card.tsx")
   - 修改分类标签组件
   - 调整标签布局
   - 添加动画效果
4. read_file("components/blog/post-card.tsx")
   - 验证修改已正确应用
     \`\`\`

### 示例 2：修改 API 路由

\`\`\`markdown
**任务**：为文章 API 添加新的查询参数

**步骤**：

1. read_file("app/api/posts/route.ts")
   - 查看当前的 API 实现
   - 了解现有的查询参数处理
2. 分析修改需求：
   - 添加新的查询参数
   - 更新类型定义
   - 保持向后兼容
3. edit_file("app/api/posts/route.ts")
   - 添加新参数的处理逻辑
   - 更新响应格式
4. edit_file("types/blog.ts")
   - 更新相关类型定义
5. read_file 验证两个文件
   \`\`\`

## 特殊情况处理

### 1. 新建文件

对于新建文件，可以输出完整代码：
\`\`\`markdown
由于是新建文件 \`components/new-component.tsx\`，
我将提供完整的代码内容供您创建：
\`\`\`

### 2. 大规模重构

如果需要重构整个文件：

1. 先说明重构的原因和影响
2. 列出将要修改的内容
3. 询问用户是否继续
4. 使用工具逐步进行修改

### 3. 用户明确要求输出代码

如果用户明确说：

- "请输出代码让我手动替换"
- "请给我完整的代码"
- "请把代码发给我"

此时可以输出代码块，但仍需说明：
\`\`\`markdown
根据您的要求，这是完整的代码：
（注意：推荐使用工具修改以获得更好的体验）
\`\`\`

### 4. 多文件协同修改

当需要修改多个文件时：

1. 按依赖顺序修改
2. 先修改类型定义
3. 再修改实现文件
4. 最后修改使用文件
5. 每个文件都要验证

## 修改时的注意事项

### 提供充分的上下文

修改代码时，必须提供足够的上下文：

- 修改前后各3-5行代码
- 确保修改位置唯一可识别
- 包含足够的特征代码

### 保持代码风格一致

- 使用项目的 ESLint 和 Prettier 配置
- 保持现有的缩进和换行风格
- 遵循项目的命名约定
- 保持导入语句的顺序

### 类型安全

- 不要删除或忽略 TypeScript 类型
- 修改时同步更新类型定义
- 确保类型推断正确

### 响应式和国际化

- 保持响应式设计
- 不要硬编码文本（使用字典）
- 考虑明暗主题兼容性

## 总结清单

在修改代码前，请确认：

- [ ] 已使用 `read_file` 读取文件
- [ ] 了解了现有代码结构
- [ ] 确定了修改的具体位置
- [ ] 准备使用工具而非输出代码块

在修改代码后，请确认：

- [ ] 修改已正确应用
- [ ] 代码格式正确
- [ ] 类型定义完整
- [ ] 没有破坏现有功能
- [ ] 保持了代码风格一致

## 效果对比

### ❌ 错误方式

\`\`\`typescript
// AI 输出：
"这是修改后的完整代码，请复制替换："

export function PostCard({ post }: PostCardProps) {
// ... 完整代码 200 行
}
\`\`\`
**问题**：

- 用户需要手动复制粘贴
- 容易出错
- 失去版本控制清晰度

### ✅ 正确方式

\`\`\`markdown
AI：我将优化分类标签的样式，现在开始修改...

[使用 edit_file 工具修改]

AI：修改已完成，我已经：

1. 优化了分类标签的渐变效果
2. 添加了悬停动画
3. 改进了标签布局

您可以直接预览修改并点击 Accept 接受更改。
\`\`\`
**优势**：

- 直接预览差异
- 一键接受修改
- 版本控制清晰

---

**遵循这个工作流程，可以确保代码修改的一致性、可靠性和高效性！**

# 代码修改工作流规范

## AI 代码修改标准流程

**重要：本项目要求 AI 助手在修改代码时，始终使用工具而非输出代码块。**

## 核心原则

### 为什么使用工具修改代码？

- ✅ 用户可以直接预览和接受修改（Accept）
- ✅ 保持版本控制清晰
- ✅ 避免手动复制粘贴错误
- ✅ 更高效的开发工作流
- ✅ 可以精确定位修改位置
- ✅ 支持增量修改，不影响其他代码

### 禁止的做法

- ❌ 直接输出完整代码块让用户复制
- ❌ 输出部分代码片段让用户手动添加
- ❌ 不先读取文件就假设其内容

## 标准工作流程

### 第 1 步：读取文件

使用 `read_file` 工具读取文件内容，了解：

- 当前代码结构
- 已有的实现
- 代码风格和格式
- 依赖关系和导入

### 第 2 步：分析修改需求

- 确定需要修改的具体位置
- 识别需要保留的代码
- 规划修改范围和影响
- 确保不破坏现有功能

### 第 3 步：执行修改

**必须使用工具进行修改**

- 使用 `edit_file` 或其他相应工具
- 提供足够的上下文（修改前后的代码）
- 确保修改位置唯一可识别

### 第 4 步：验证修改

修改完成后，再次使用 `read_file` 确认：

- 修改已正确应用
- 代码格式正确
- 没有引入语法错误
- 保持代码风格一致

## 不同文件类型的修改规则

### 组件文件 (components/\*)

\`\`\`bash

1. read_file - 读取组件文件
2. 分析修改需求（props、state、hooks）
3. edit_file - 修改组件逻辑或UI
4. read_file - 验证修改结果
   \`\`\`

**注意事项**：

- 保持组件的 TypeScript 类型定义
- 不要破坏现有的 props 接口
- 保持导入语句的顺序和风格

### 页面文件 (app/[lang]/\*)

\`\`\`bash

1. read_file - 读取页面文件
2. 了解路由结构和数据流
3. edit_file - 修改页面逻辑
4. 确保不破坏路由和布局
   \`\`\`

**注意事项**：

- Next.js App Router 的约定
- 保持 async/await 的使用
- 不要修改文件的导出方式

### 工具函数 (lib/_, utils/_)

\`\`\`bash

1. read_file - 读取工具函数
2. 了解函数签名和依赖
3. edit_file - 修改函数实现
4. 确保向后兼容
   \`\`\`

**注意事项**：

- 保持函数签名不变
- 添加必要的类型注解
- 保持导出方式一致

### 样式文件 (styles/_, _.scss)

\`\`\`bash

1. read_file - 读取样式文件
2. 了解现有样式结构和变量
3. edit_file - 添加或修改样式
4. 确保样式不冲突
   \`\`\`

**注意事项**：

- 使用项目定义的 CSS 变量
- 保持 Tailwind 和 SCSS 的使用规范
- 不要覆盖全局样式

### 配置文件 (_.config._, tsconfig.json)

\`\`\`bash

1. read_file - 完整读取配置文件
2. 确认修改的配置项
3. edit_file - 谨慎修改配置
4. 验证配置语法
   \`\`\`

**注意事项**：

- 配置文件修改影响整个项目
- 修改前确认影响范围
- 保持配置的兼容性

## 工作流程示例

### 示例 1：优化博客卡片组件

\`\`\`markdown
**任务**：优化博客卡片上的分类和标签UI

**步骤**：

1. read_file("components/blog/post-card.tsx")
   - 查看当前的分类标签实现
   - 了解标签的布局结构
2. 分析修改需求：
   - 改进分类标签的视觉效果
   - 优化标签的布局和间距
   - 添加悬停动画效果
3. edit_file("components/blog/post-card.tsx")
   - 修改分类标签组件
   - 调整标签布局
   - 添加动画效果
4. read_file("components/blog/post-card.tsx")
   - 验证修改已正确应用
     \`\`\`

### 示例 2：修改 API 路由

\`\`\`markdown
**任务**：为文章 API 添加新的查询参数

**步骤**：

1. read_file("app/api/posts/route.ts")
   - 查看当前的 API 实现
   - 了解现有的查询参数处理
2. 分析修改需求：
   - 添加新的查询参数
   - 更新类型定义
   - 保持向后兼容
3. edit_file("app/api/posts/route.ts")
   - 添加新参数的处理逻辑
   - 更新响应格式
4. edit_file("types/blog.ts")
   - 更新相关类型定义
5. read_file 验证两个文件
   \`\`\`

## 特殊情况处理

### 1. 新建文件

对于新建文件，可以输出完整代码：
\`\`\`markdown
由于是新建文件 \`components/new-component.tsx\`，
我将提供完整的代码内容供您创建：
\`\`\`

### 2. 大规模重构

如果需要重构整个文件：

1. 先说明重构的原因和影响
2. 列出将要修改的内容
3. 询问用户是否继续
4. 使用工具逐步进行修改

### 3. 用户明确要求输出代码

如果用户明确说：

- "请输出代码让我手动替换"
- "请给我完整的代码"
- "请把代码发给我"

此时可以输出代码块，但仍需说明：
\`\`\`markdown
根据您的要求，这是完整的代码：
（注意：推荐使用工具修改以获得更好的体验）
\`\`\`

### 4. 多文件协同修改

当需要修改多个文件时：

1. 按依赖顺序修改
2. 先修改类型定义
3. 再修改实现文件
4. 最后修改使用文件
5. 每个文件都要验证

## 修改时的注意事项

### 提供充分的上下文

修改代码时，必须提供足够的上下文：

- 修改前后各3-5行代码
- 确保修改位置唯一可识别
- 包含足够的特征代码

### 保持代码风格一致

- 使用项目的 ESLint 和 Prettier 配置
- 保持现有的缩进和换行风格
- 遵循项目的命名约定
- 保持导入语句的顺序

### 类型安全

- 不要删除或忽略 TypeScript 类型
- 修改时同步更新类型定义
- 确保类型推断正确

### 响应式和国际化

- 保持响应式设计
- 不要硬编码文本（使用字典）
- 考虑明暗主题兼容性

## 总结清单

在修改代码前，请确认：

- [ ] 已使用 `read_file` 读取文件
- [ ] 了解了现有代码结构
- [ ] 确定了修改的具体位置
- [ ] 准备使用工具而非输出代码块

在修改代码后，请确认：

- [ ] 修改已正确应用
- [ ] 代码格式正确
- [ ] 类型定义完整
- [ ] 没有破坏现有功能
- [ ] 保持了代码风格一致

## 效果对比

### ❌ 错误方式

\`\`\`typescript
// AI 输出：
"这是修改后的完整代码，请复制替换："

export function PostCard({ post }: PostCardProps) {
// ... 完整代码 200 行
}
\`\`\`
**问题**：

- 用户需要手动复制粘贴
- 容易出错
- 失去版本控制清晰度

### ✅ 正确方式

\`\`\`markdown
AI：我将优化分类标签的样式，现在开始修改...

[使用 edit_file 工具修改]

AI：修改已完成，我已经：

1. 优化了分类标签的渐变效果
2. 添加了悬停动画
3. 改进了标签布局

您可以直接预览修改并点击 Accept 接受更改。
\`\`\`
**优势**：

- 直接预览差异
- 一键接受修改
- 版本控制清晰

---

**遵循这个工作流程，可以确保代码修改的一致性、可靠性和高效性！**
